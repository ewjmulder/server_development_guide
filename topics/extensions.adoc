[[_extensions]]

== Extending Server

{{book.project.name}} SPI framework offers possibility to implement or override particular built-in providers. However {{book.project.name}}
also provides capabilities to extend it's core functionalities and domain. This includes possibilities to:

* Add custom REST endpoints to {{book.project.name}} server
* Add your own custom SPI
* Add custom JPA entities to the {{book.project.name}} data model

[[_extensions_rest]]
=== Add custom REST endpoints

This is very powerful extension, which allows you to deploy your own REST endpoints to {{book.project.name}} server. It allows many things, for example
possibility to trigger functionality on {{book.project.name}} server, which is not available through default set of built-in {{book.project.name}} REST endpoints.

To add custom REST endpoint, you need to implement `RealmResourceProviderFactory` and `RealmResourceProvider` interfaces. `RealmResourceProvider` has important method :

[source,java]
----

Object getResource();

----

which allows you to return object, which acts as https://jax-rs-spec.java.net/[JAX-RS Resource]. For more details, see the Javadoc and our examples.
There is very simple example in example distribution in `providers/rest` and there is more advanced example in `providers/domain-extension`,
which shows how to add authenticated REST endpoint and other functionalities like <<extensions.adoc#_extensions_spi,Adding your own SPI>>
or <<extensions.adoc#_extensions_jpa,Extending datamodel with your own JPA entities>>.

For details on how to package and deploy a custom provider refer to the <<providers.adoc#_providers,Service Provider Interfaces>> chapter.

[[_extensions_spi]]
=== Add your own custom SPI

This is useful especially with the <<extensions.adoc#_extensions_rest,Custom REST endpoints>>. To add your own kind of SPI, you need to
implement interface `org.keycloak.provider.Spi` and define the ID of your SPI and the `ProviderFactory` and `Provider` classes. It can look like this:

[source,java]
----
package org.keycloak.examples.domainextension.spi;

import ...

public class ExampleSpi implements Spi {

    @Override
    public boolean isInternal() {
        return false;
    }

    @Override
    public String getName() {
        return "example";
    }

    @Override
    public Class<? extends Provider> getProviderClass() {
        return ExampleService.class;
    }

    @Override
    @SuppressWarnings("rawtypes")
    public Class<? extends ProviderFactory> getProviderFactoryClass() {
        return ExampleServiceProviderFactory.class;
    }

}

----

Then you need to create file `META-INF/services/org.keycloak.provider.Spi` and add the class of your SPI to it. For this example, it can look like this:

[source]
----
org.keycloak.examples.domainextension.spi.ExampleSpi
----

Next step is to create interfaces `ExampleServiceProviderFactory`, which extends from `ProviderFactory` and `ExampleService`, which extends from `Provider`.
The `ExampleService` will usually contain any business methods you need for your use-case. Note that `ExampleServiceProviderFactory` instance
is always scoped per-application, however `ExampleService` is scoped per-request (or more accurately per `KeycloakSession` lifecycle).

Finally you need to implement your providers in same manner like described in  <<providers.adoc#_providers,Service Provider Interfaces>> chapter.

For more details, take a look at example distribution at `providers/domain-extension`, which shows the Example SPI similar to above.

[[_extensions_jpa]]
=== Add custom JPA entities to the {{book.project.name}} data model

When you have your own REST endpoint, you may need to extend {{book.project.name}} datamodel as well. We allow possibility to add your
own entities into {{book.project.name}} JPA `EntityManager` .

For adding your own JPA entities, you need to implement `JpaEntityProviderFactory` and `JpaEntityProvider` . The `JpaEntityProvider` has some methods,
which allows you to return set of your custom JPA entities. The example implementation can look like this:

[source,java]
----
public class ExampleJpaEntityProvider implements JpaEntityProvider {

    // Set of your JPA entities
    @Override
    public List<Class<?>> getEntities() {
        return Collections.<Class<?>>singletonList(Company.class);
    }

    // This is used to return custom location of Liquibase changelog file.
    // You can return null if you don't want to use Liquibase and to create and update DB schema
    @Override
    public String getChangelogLocation() {
    	return "META-INF/example-changelog.xml";
    }

    // Helper method, which will be used internally by Liquibase
    @Override
    public String getFactoryId() {
        return "sample";
    }

    ...
}
----

In the example above, we added single JPA entity represented by class `Company` . In the code of your REST endpoint, you can then use something like
this to retrieve `EntityManager` and call DB operations on it.


[source,java]
----
EntityManager em = session.getProvider(JpaConnectionProvider.class).getEntityManager();
Company myCompany = em.find(Company.class, "123");
----

The methods `getChangelogLocation` and `getFactoryId` are important to support automatic updating of your entities by Liquibase. http://www.liquibase.org/[Liquibase]
is framework for updating database schema, which {{book.project.name}} internally uses to create DB schema and update DB schema among versions. You may need to use
it as well and create changelog for your entities. Note that versioning of your own liquibase changelog is independent
on {{book.project.name}} versions. In other words, when you update to new {{book.project.name}} version, you are not forced to update your
schema at the same time. And also viceversa, you can update your schema even without updating {{book.project.name}} version. The Liquibase update
is always checked at the server startup, so to trigger DB update of your schema, you just need to add new changeset to your liquibase changelog file (in the example above
it's the file `META-INF/example-changelog.xml`, which must be packed in same JAR like the JPA entities and `ExampleJpaEntityProvider` ) and then restart server.
DB schema will be automatically updated at that point.

For more details, take a look at example distribution at example `providers/domain-extension`, which shows the `ExampleJpaEntityProvider` and `example-changelog.xml` described above.

NOTE: Don't forget to always backup your database before doing any changes in Liquibase changelog and triggering DB update.